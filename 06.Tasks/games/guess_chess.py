# 2. Добавьте в пакет, созданный на семинаре шахматный модуль. 
# Внутри него напишите код, решающий задачу о 8 ферзях.
# Известно, что на доске 8×8 можно расставить 8 ферзей так, чтобы они не били друг друга. 
# Вам дана расстановка 8 ферзей на доске, определите, есть ли среди них пара бьющих друг друга. 
# Программа получает на вход восемь пар чисел, каждое число от 1 до 8 - координаты 8 ферзей. 
# Если ферзи не бьют друг друга верните истину, а если бьют - ложь.
from random import randint
def queens(*args):
    """
    Расставляет 8 ферзей на шахматной доске и проверяет их корректное размещение.
    https://en.wikipedia.org/wiki/Eight_queens_puzzle

    Аргументы:
    args (tuple): 8 Кортежей (0-7) с координатами ферзей в формате (x, y).

    Возвращает:
    bool: 
    False - хотя бы одна пара ферзей бьют друг друга (по горизонтали, вертикали или диагонали).
    True - никто из ферзей не бьют любого другого.
    """
    size = len(args)
    board =[[0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0]]

    for i, queen in enumerate(args, 1): # Перебор 8 ферзей
        x, y = queen # Получение координат каждого ферзя
        # Просмотр всех направлений перед установкой i-го ферзя
        if board[y][x] == 0: # Если текущая точка (y,x) имеет значение ноль
            # Горизонталь (--). Пробегаем всю ось x по значению y горизонтальным лучом i-го ферзя
            for h in range(size): # h - horizontal
                if board[y][h] == 0: # Горизонталь h, y постоянен
                    pass           # Горизонталь чиста
                else: return False # На горизонтали уже есть занятая клетка, возвращаем False
            # Вертикаль (|). Пробегаем всю ось y по значению x вертикальным лучом i-го ферзя
            for v in range(size): # v - vertical
                if board[v][x] == 0: # Вертикаль v, х постоянен
                    pass           # Вся вертикаль чистая
                else: return False # На вертикали уже есть занятая клетка, возвращаем False
            # Спуск (\). Пробегаем по левой диагонали, проходящие через текущую точку
            l_start = (x-y, 0) if x-y >= 0 else (0, y-x) #  (x,y) Начало левой диагонали. Смотрим что больше x или y
            l_end = (size-1-l_start[1], size-1-l_start[0]) # (x,y) Конец левой диагонали. Конец имеет перевернутые координаты вычитаемые из индекса последней клетки (7) старта диагонали
            while l_start != l_end: # Пока старт не сравняется с концом спуска.
                if board[l_start[1]][l_start[0]] == 0: # Проверяем не занята ли клетка
                    l_start = (l_start[0]+1, l_start[1]+1) # если свободна клетка, увеличиваем счетчик (координаты)
                else: return False # Если клетка занята другим ферзем, возвращаем False
            # Подъём (/). Пробегаем по провой диагонали, проходящие через текущую точку    
            r_start = (0, x+y) if (x+y) < size else (x-(size-1-y), x+(size-1-x)) # начало подъёма. Учитываем условие, что сумма координат либо больше, либо меньше размера доски (8)
            r_end = (r_start[1], r_start[0]) # Конечные координаты подъёма развернуты относительно стартовых координат.
            while r_start[0] <= r_end[0]: # Пока старт не сравняется с концом подъёма.
                if board[r_start[1]][r_start[0]] == 0:  # Проверяем не занята ли клетка, либо не стоит свой ферзь
                    r_start = (r_start[0]+1, r_start[1]-1) # старт подъема увеличиваем на единицу для продолжения цикла
                else: return False 
            board[y][x] = i # Ставим i-того ферзя
        else: # Если клетка занята, возвращаем False
            return False
    return True # Все условия корректны, возвращаем True

# 8. Напишите функцию в шахматный модуль. 
# Используйте генератор случайных чисел для случайной расстановки ферзей в задаче выше. 
# Проверяйте различный случайные варианты и выведите 4 успешных расстановки.
def positions(res_amount, mode=0, board_size=8) -> list:
    res_set = set()
    maxi = int("76543210", board_size)
    mini = int("01234567", board_size)
    match mode:
        case 0:
            for i in range(mini, maxi):
                oc = oct(i)[2:].zfill(board_size)
                q0 = (int(oc[0],8), 0)
                q1 = (int(oc[1],8), 1)
                q2 = (int(oc[2],8), 2)
                q3 = (int(oc[3],8), 3)
                q4 = (int(oc[4],8), 4)
                q5 = (int(oc[5],8), 5)
                q6 = (int(oc[6],8), 6)
                q7 = (int(oc[7],8), 7)
                if queens(q0, q1, q2, q3, q4, q5, q6, q7):
                    res_set.add((q0, q1, q2, q3, q4, q5, q6, q7))
                if len(res_set) == res_amount: 
                    break
        case 1:
            count = 1
            while count <= res_amount:
                rand_num = randint(mini, maxi)
                oc = oct(rand_num)[2:].zfill(board_size)
                q0 = (int(oc[0],8), 0)
                q1 = (int(oc[1],8), 1)
                q2 = (int(oc[2],8), 2)
                q3 = (int(oc[3],8), 3)
                q4 = (int(oc[4],8), 4)
                q5 = (int(oc[5],8), 5)
                q6 = (int(oc[6],8), 6)
                q7 = (int(oc[7],8), 7)
                if queens(q0, q1, q2, q3, q4, q5, q6, q7):
                    res_set.add((q0, q1, q2, q3, q4, q5, q6, q7))
                    count += 1 
        case 2:
            with open('queens', 'r') as f:
                indexes = f.read().splitlines()
            for i in indexes:
                oc = oct(int(i))[2:].zfill(board_size)
                q0 = (int(oc[0],8), 0)
                q1 = (int(oc[1],8), 1)
                q2 = (int(oc[2],8), 2)
                q3 = (int(oc[3],8), 3)
                q4 = (int(oc[4],8), 4)
                q5 = (int(oc[5],8), 5)
                q6 = (int(oc[6],8), 6)
                q7 = (int(oc[7],8), 7)
                if queens(q0, q1, q2, q3, q4, q5, q6, q7):
                    res_set.add((q0, q1, q2, q3, q4, q5, q6, q7))
                if len(res_set) == res_amount: 
                    break
        case _:
            return set("0 - direct mode", "1 - random mode", "2 - cheat mode")
    return res_set

def print_board(*args):
    board =[[0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0]]

    for i, queen in enumerate(args, 1): # Перебор 8 ферзей
        x, y = queen # Получение координат каждого ферзя
        # Расстановка ферзей
        if board[y][x] == 0: # Если текущая точка (y,x) имеет значение ноль
            board[y][x] = i # Ставим i-того ферзя (ферзь№1=10)
    print(*board, sep='\n')


if __name__ == "__main__":

    # print(queens((5,0),(3,1),(6,2),(0,3),(7,4),(1,5),(4,6),(2,7)))
    print_board((7, 3), (0, 4), (2, 0), (5, 7), (1, 2), (6, 5), (3, 6), (4, 1))
