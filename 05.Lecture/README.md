# Итераторы и генераторы

● Итератор — это объект, представляющий поток данных; объект возвращает
данные по одному элементу за раз. Итератор Python должен поддерживать
метод с именем __next__ (), который не принимает аргументов и всегда
возвращает следующий элемент потока.
● Генератор — это объект, который сразу при создании не вычисляет значения
всех своих элементов. Он хранит в памяти только последний вычисленный
элемент, правило перехода к следующему и условие, при котором
выполнение прерывается. Вычисление следующего значения происходит
3лишь при выполнении метода next(). Предыдущее значение при этом
теряется.
● Факториал — функция, определённая на множестве неотрицательных целых
чисел. Название происходит от лат. factorialis — действующий, производящий,
умножающий; обозначается n!, произносится эн факториал. Факториал
натурального числа n определяется как произведение всех натуральных
чисел от 1 до n включительно.

## Однострочники

### Обмен значений

```
a, b = b, a
```

### Распаковка коллекций

```
>>> a, b, c = input("Три символа: ")
Три символа: ABC
>>> print(f'{a=} {b=} {c=}')
a='A' b='B' c='C'
```

### Упаковка со звёздочкой

```
>>> data = ["один", "два", "три", "четыре", "пять", "шесть", "семь"]
>>> a, b, c, *d = data
>>> print(f'{a=} {b=} {c=} {d=}')
a='один' b='два' c='три' d=['четыре', 'пять', 'шесть', 'семь']
>>> a, b, *c, d = data
>>> print(f'{a=} {b=} {c=} {d=}')
a='один' b='два' c=['три', 'четыре', 'пять', 'шесть'] d='семь'
>>> *a, b, c, d = data
>>> print(f'{a=} {b=} {c=} {d=}')
a=['один', 'два', 'три', 'четыре'] b='пять' c='шесть' d='семь'
```

### Упаковка мусора *_

```
>>> link ='https://docs.python.org/3/faq/programming.html#how-can-i-pass-optional-or-keyword-parameters-from-one-function-to-another'
>>> prefix, *_, suffix = link.split('/')
>>> _
['', 'docs.python.org', '3', 'faq']
```

### Распаковка со звёздочкой

```
>>> data = [2, 4, 6, 8, 10]
>>> print(*data, sep='\t')
2	4	6	8	10
```

### Множественное присваивание

```
>>> a = b = c =0
>>> a += 42
>>> print(f'{a=} {b=} {c=}')
a=42 b=0 c=0
```

### Множественное сравнение

```
>>> a = b = c = 42
>>> if a == b == c:
...     print('Полное совпадение')
... 
Полное совпадение
```

### Плохие однострочники
Отсутствие перехода на новую строку после двоеточия и запись нескольких строк кода в одну через точку с запятой — плохой стиль программирования.

```
>>> a = 12; b = 42; c = 73
>>> if a < b < c: b = None; print('Ужасный код')
... 
Ужасный код
```

# Итераторы

Любая Python коллекция (список, словарь, строка, множество, словарь, кортеж) предоставляют интерфейс итератора. 
Порядок сортировки элементов множества зависит от их хэша.

## Функции iter() и next()

Объект является итерируемым, если поддерживает работу дандер методов __iter__ (или __getitem__) и __next__ - возвращает очередной элемент коллекции или исключение StopIteratio

### iter()

Формат iter(object[, sentinel])
object является обязательным аргументом
sentinel - значение по умолчанию, выходится для вызываемых (функции) объектов итераторов, когда в нем закончились элементы:

```
import functools
f = open('mydata.bin', 'rb')
for block in iter(functools.partial(f.read, 16), b''):
    print(block)
f.close()
```
В примере выше открыли бинарный файл на чтение байт. В цикле считываем блоки по 16 байт и выводим их на печать. Чтение прекратиться после считывание пустого байта b’’, окончания файла.

**Свойства итераторов:**
- Напрямую извлечь данные из итератора не получится. На выход получим: list_iterator, tuple_iterator, set_iterator,dict_itemiterator, etc.
- Чтобы получить элементы, можно распаковать итератор через звёздочку.
- Итератор является одноразовым объектом. Получив все элементы коллекции один раз он перестаёт работать.

### next()

Формат next(iterator[, default])

Каждый вызов next() возвращает очередной элемент итератора.

```
>>> data = [2, 4, 6, 8]
>>> list_iter = iter(data)
>>> print(next(list_iter))
2
>>> print(next(list_iter))
4
>>> print(next(list_iter))
6
>>> print(next(list_iter))
8
>>> print(next(list_iter))
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
StopIteration
```

# Генераторы

Генератором могут быть не только однострочники

Генераторы не хранят данные в памяти, а вычисляют их по мере необходимости

## range()
При создании генератора мы указываем диапазон перебираемых целых чисел, но не сохраняем их в памяти. Каждое из значений генерируется на очередном витке цикла.

```
>>> a = range(0, 10, 2)
>>> print(f'{a=}, {type(a)=}, {a.__sizeof__()=}, {len(a)}')
a=range(0, 10, 2), type(a)=<class 'range'>, a.__sizeof__()=48, 5
>>> b = range(-1_000_000, 1_000_000, 2)
>>> print(f'{b=}, {type(b)=}, {b.__sizeof__()=}, {len(b)}')
b=range(-1000000, 1000000, 2), type(b)=<class 'range'>, b.__sizeof__()=48, 1000000
```

Генератор на пять значений и генератор b на 1 млн. значений занимаютодинаковое место в памяти.

## Генераторные выражения ()

Python позволяют создать собственный генератор, перебирающий значения.
Для создания генераторного выражения используют круглые скобки, внутри которых прописывается логика выражения

### for и if в генераторах

Классические вложенные циклы:

```
for expr in sequense1:
    if not condition1:
        continue
    for expr in sequense2:
        if not condition2:
            continue
            ...
        for expr in sequenseN:
            if not conditionN:
                continue
```

Можно записать в виде генератора

```
gen = (expression for expr in sequense1 if condition1
        for expr in sequense2 if condition2
        for expr in sequense3 if condition3
        ...
        for expr in sequenseN if conditionN)
```

- Не стоит злоупотреблять количеством вложенных циклов.
- Ограничение в 80 (120) символов на строку касается и генераторов
- Эти ограничения касаются так же генераторов списков, множеств и словарей.

## Генераторы списков []

Другие названия: List comprehensions, list comp, списковое включение. Это не генераторное выражение, т.к. список формируется полностью и может занимать всю память, генератор же занимает очень мала места в памяти и вычисление нужного значения происходит в момент исполнения 

```
>>> x = [1, 1, 2, 3, 5, 8, 13]
>>> y = [1, 2, 6, 24, 120, 720]
>>> res = [i + j for i in x if i % 2 != 0 for j in y if j != 1]
>>> print(res)
[3, 7, 25, 121, 721, 3, 7, 25, 121, 721, 5, 9, 27, 123, 723, 7, 11, 29, 125, 725, 15, 19, 37, 133, 733]
```
У генератора списка, такой же синтаксис как и у генераторного выражения, это касается и условий и циклов.

При написании кода заранее решите нужна вам сгенерированная коллекция целиком или нет.

## Генераторы множеств {}

Или Set comprehensions. Синтаксис аналогичный верхним генераторам. 

```
>>> my_setcomp = {chr(i) for i in range(97, 123)}
>>> print(my_setcomp)
{'w', 'x', 'n', 'a', 'r', 's', 'z', 'p', 'h', 'y', 'f', 'l', 'k', 'q', 'c', 'o', 'j', 'e', 'u', 'b', 'v', 'd', 't', 'm', 'g', 'i'}
```

У множеств нет сортировки по значениям и выводятся уникальные элементы без повторов

## Генераторы словарей {:}

Dict comprehensions. 

```
>>> my_dictcomp = {i: chr(i) for i in range(97, 123)}
>>> print(my_dictcomp)
{97: 'a', 98: 'b', 99: 'c', 100: 'd', 101: 'e', 102: 'f', 103: 'g', 104: 'h', 105: 'i', 106: 'j', 107: 'k', 108: 'l', 109: 'm', 110: 'n', 111: 'o', 112: 'p', 113: 'q', 114: 'r', 115: 's', 116: 't', 117: 'u', 118: 'v', 119: 'w', 120: 'x', 121: 'y', 122: 'z'}
```

Ключами словаря должны быть объектами неизменяемого типа.

### Генераторная функция (функция генератора)

Это генератор не в одну строку, а как отдельную функция.

Пример генераторной функции для вычисления факториала

```
def factorial(n):
    number = 1
    result = []
    for i in range(1, n + 1):
        number *= i
        result.append(number)
    return result

for i, num in enumerate(factorial(10), start=1):
    print(f'{i}! = {num}')
```

## Команда yield

Применяется в функциях, но в отличие от return позволяет при повторном вызове функции продолжить работу с момента остановки.

Перепишем генераторную функцию в генератор:

```
def factorial(n):
    number = 1
    for i in range(1, n + 1):
        number *= i
        yield number

for i, num in enumerate(factorial(10), start=1):
    print(f'{i}! = {num}')
```

В нашем примере, команда неявный return завершает работу генератора вызовом исключения StopIteration.

## iter() и next() для генераторов

Они позволяют работать с созданными генераторами

```
my_iter = iter(factorial(4))
print(my_iter)
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
print(next(my_iter))
```