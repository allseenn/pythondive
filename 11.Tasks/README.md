# Урок 11. ООП. Особенности Python

## 1. Информация об авторе и времени создания

Разработайте программное обеспечение для ведения журнала событий. Вам необходимо создать класс, который будет представлять строки журнала и включать в себя информацию об авторе и времени создания каждой записи.

### Условие задачи:

Создайте класс MyStr, который наследуется от встроенного класса str и добавлять дополнительную информацию о создателе строки и времени ее создания. Этот класс будет представлять строки с информацией о событиях. 

Класс MyStr должен иметь следующие атрибуты и методы: 

**value** (str): Строковое значение с описанием события.
**author** (str): Имя автора, создавшего запись.
**time**: Время создания записи в формате '%Y-%m-%d %H:%M'. 

Магические методы (Dunder-методы):

Реализуйте метод __new__(cls, value, author), который создает новый объект класса MyStr с заданным value и author. Метод также автоматически фиксирует время создания записи. В этом методе создается новый объект MyStr с указанными атрибутами и текущим временем в атрибуте time.

Реализуйте метод __str__(self), который возвращает строковое представление объекта класса MyStr с информацией о событии, авторе и времени создания.

Реализуйте метод __repr__(self), который возвращает строковое представление объекта класса MyStr.  
Метод __repr__ возвращает строку, которая может быть использована для создания точно такого же объекта MyStr с теми же значениями value иa uthor

### Пример использования. 

**На входе:**

```
event = MyStr("Завершилось тестирование", "John")
print(event)
```

**На выходе:**

```
Завершилось тестирование (Автор: John, Время создания: [ в формате '%Y-%m-%d %H:%M'])
```

**На входе:**
```
my_string = MyStr("Пример текста", "Иван")
print(my_string)
```

**На выходе:**
```
Пример текста (Автор: Иван, Время создания: 2023-10-10 15:56)

```

**На входе:**

```
my_string = MyStr("Мама мыла раму", "Маршак")
print(repr(my_string))
```

**На выходе:**
```
MyStr('Мама мыла раму', 'Маршак')
```

## 2. Класс Archive - архив текстовых и числовых записей

Разработайте программу для хранения и управления текстовыми и числовыми записями.
Вам нужно создать класс Archive, который будет представлять архив и реализовывать следующую функциональность: 

### Методы и операции:

При создании экземпляра класса Archive с указанием текстовой и числовой записи (text и number), записи добавляются в соответствующие атрибуты archive_text и archive_number. Если архив уже существует, текущие записи (text и number) добавляются в архив.

Метод __str__ возвращает строковое представление объекта, включая текущие записи (text и number) и архивированные записи (archive_text и archive_number).

Метод __repr__ возвращает строковое представление объекта, которое можно использовать для создания нового объекта того же класса с теми же записями.

Архивированные записи могут быть получены через атрибуты archive_text и archive_number.

Метод __new__ - это статический метод, который создает новый экземпляр класса. Первым аргументом метод __new__ получает ссылку на класс (cls), а затем может принимать дополнительные аргументы. Метод __new__ проверяет, существует ли уже экземпляр класса Archive (с использованием атрибута _instance). Если экземпляр существует, то метод вместо создания нового экземпляра добавляет текущие значения text и number в архив (списки archive_text и archive_number) для уже существующего экземпляра. Если экземпляр еще не существует, метод создает новый экземпляр класса Archive с пустыми архивами для текстовых и числовых записей. В любом случае метод возвращает созданный или существующий экземпляр класса Archive. 

Метод __init__ - это конструктор экземпляра класса, который вызывается после создания экземпляра с использованием метода __new__. Метод __init__ принимает два аргумента: text (строка) и number (целое число или число с плавающей точкой). В методе __init__устанавливаются атрибуты text и number текущего экземпляра класса для хранения переданных текстовой и числовой записей. Эти записи могут быть затем добавлены в архив (списки archive_text и archive_number) с использованием метода __new__. 

### Пример

**На входе:**
```
archive1 = Archive("Запись 1", 42)
archive2 = Archive("Запись 2", 3.14)
```

**На выходе:**
```
Text is Запись 1 and number is 42. Also ['Запись 1'] and [42]
Text is Запись 2 and number is 3.14. Also ['Запись 1', 'Запись 2'] and [42, 3.14]
```

## 3. Класс Rectangle - работа с прямоугольниками

Разработайте программу для работы с прямоугольниками. Необходимо создать класс Rectangle, который будет представлять прямоугольник с заданными шириной и высотой.

**Атрибуты класса:**

width (int): Ширина прямоугольника. height (int): Высота прямоугольника.

**Методы класса:**

__init__(self, width, height=None): Конструктор класса. Принимает ширину и высоту прямоугольника. Если высота не указана (по умолчанию None), то считается, что прямоугольник является квадратом, и высота устанавливается равной ширине.

perimeter(self): Метод для вычисления периметра прямоугольника. Возвращает целое число - значение периметра.

area(self): Метод для вычисления площади прямоугольника. Возвращает целое число - значение площади.

__add__(self, other): Магический метод, который определяет операцию сложения (+) для двух прямоугольников. Принимает другой прямоугольник other. Создает новый прямоугольник, который представляет собой объединение исходных прямоугольников по периметру. Возвращает новый прямоугольник.

__sub__(self, other): Магический метод, который определяет операцию вычитания (-) одного прямоугольника из другого. Принимает вычитаемый прямоугольник other. Создает новый прямоугольник, представляющий разницу периметров исходных прямоугольников, и вычисляет высоту на основе этой разницы. Возвращает новый прямоугольник.

__lt__(self, other): Магический метод, который определяет операцию "меньше" (<) для двух прямоугольников. Принимает другой прямоугольник other. Возвращает True, если площадь первого прямоугольника меньше площади второго, иначе False.

__eq__(self, other): Магический метод, который определяет операцию "равно" (==) для двух прямоугольников. Принимает другой прямоугольник other. Возвращает True, если площади равны, иначе False.

__le__(self, other): Магический метод, который определяет операцию "меньше или равно" (<=) для двух прямоугольников. Принимает другой прямоугольник other. Возвращает True, если площадь первого прямоугольника меньше или равна площади второго, иначе False.

__str__(self): Магический метод, возвращающий строковое представление прямоугольника. Возвращает строку, описывающую ширину и высоту прямоугольника.

__repr__(self): Магический метод, возвращающий строковое представление прямоугольника, которое может быть использовано для создания нового объекта такого же класса с теми же атрибутами.

Пояснение:

Метод __add__ объединяет два прямоугольника по периметру и создает новый прямоугольник.
Метод __sub__ вычитает один прямоугольник из другого, представляя разницу периметров исходных прямоугольников, и создает новый прямоугольник.
Методы сравнения __lt__, __eq__ и __le__ сравнивают прямоугольники по их площади.
Методы __str__ и __repr__ предоставляют строковое представление объекта класса Rectangle.

Пример использования:
На входе:

```
rect1 = Rectangle(5, 10)
rect2 = Rectangle(3, 7)

print(f"Периметр rect1: {rect1.perimeter()}")  
print(f"Площадь rect2: {rect2.area()}")    
print(f"rect1 < rect2: {rect1 < rect2}")        
print(f"rect1 == rect2: {rect1 == rect2}")   
print(f"rect1 <= rect2: {rect1 <= rect2}")     

rect3 = rect1 + rect2
print(f"Периметр rect3: {rect3.perimeter()}") 
rect4 = rect1 - rect2
print(f"Ширина rect4: {rect4.width}")          

```

На выходе:

```
Периметр rect1: 30
Площадь rect2: 21
rect1 < rect2: False
rect1 == rect2: False
rect1 <= rect2: False
Периметр rect3: 50
Ширина rect4: 2
```

## 4. Задача о матричных операциях

Разработать класс Matrix, представляющий матрицу и обеспечивающий базовые операции с матрицами.

Атрибуты класса:

rows (int): Количество строк в матрице.
cols (int): Количество столбцов в матрице.
data (list): Двумерный список, содержащий элементы матрицы.

Методы класса:

__init__(self, rows, cols): Конструктор класса, который инициализирует атрибуты rows и cols, а также создает двумерный список data размером rows x cols и заполняет его нулями.

__str__(self): Метод, возвращающий строковое представление матрицы. Возвращаемая строка представляет матрицу, где элементы разделены пробелами, а строки разделены символами новой строки. 

Например:
```
1 2 3
4 5 6
```

__repr__(self): Метод, возвращающий строковое представление объекта, которое может быть использовано для создания нового объекта того же класса с такими же размерами и данными.

__eq__(self, other): Метод, определяющий операцию "равно" для двух матриц. Сравнивает две матрицы и возвращает True, если они имеют одинаковое количество строк и столбцов, а также все элементы равны. Иначе возвращает False.

__add__(self, other): Метод, определяющий операцию сложения двух матриц. Проверяет, что обе матрицы имеют одинаковые размеры (количество строк и столбцов). Если размеры совпадают, создает новую матрицу, где каждый элемент равен сумме соответствующих элементов входных матриц.

__mul__(self, other): Метод, определяющий операцию умножения двух матриц. Проверяет, что количество столбцов в первой матрице равно количеству строк во второй матрице. Если условие выполняется, создает новую матрицу, где элемент на позиции [i][j] равен сумме произведений элементов соответствующей строки из первой матрицы и столбца из второй матрицы.

Пример

На входе:
```
# Создаем матрицы
matrix1 = Matrix(2, 3)
matrix1.data = [[1, 2, 3], [4, 5, 6]]

matrix2 = Matrix(2, 3)
matrix2.data = [[7, 8, 9], [10, 11, 12]]

# Выводим матрицы
print(matrix1)

print(matrix2)
```

На выходе:

```
1 2 3
4 5 6
7 8 9
10 11 12
```

На входе:
```
# Сравниваем матрицы
print(matrix1 == matrix2)
```

На выходе:
```
False
```

На входе:
```
# Выполняем операцию сложения матриц
matrix_sum = matrix1 + matrix2
print(matrix_sum)
```

На выходе:

```
8 10 12
14 16 18
```

На входе:
```
# Выполняем операцию умножения матриц
matrix3 = Matrix(3, 2)
matrix3.data = [[1, 2], [3, 4], [5, 6]]

matrix4 = Matrix(2, 2)
matrix4.data = [[7, 8], [9, 10]]

result = matrix3 * matrix4
print(result)
```

На выходе:
```
25 28
57 64
89 100
```