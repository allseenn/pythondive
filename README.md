# Погружение в Питон (Dive into Python)

## 4. Функции (Functions)
- **Функция** (подпрограмма) — фрагмент
программного кода, к которому можно обратиться из другого места
программы.
- Функции высшего порядка — это функции, которые работают с другими
функциями, либо принимая их в виде параметров, либо возвращая их.

### Вызовы, передача функций

**Вызов** функции c параметром (аргументом), всегда со скобками ():
```
>>> id("Hello")
9877568
```

**Функция высшего порядка** type() передается значение функции id():
```
>>> type(id(a))
<class 'int'>
```

**Передача** функции как объекта другой без скобок ():
```
>>> type(id)
<class 'builtin_function_or_method'>
```

**Передача** функции в переменную без скобок ():
```
>>> new_var = id
>>> new_var("Hello")
140014307657968
```

**pass** - служебное слово, которое ничего не делает:
```
def my_func():
pass
```

### Аннотация

```
def quadratic_equations(a: int | float, b: int | float, c: int |
float) -> tuple[float, float] | float | None:
    d = b ** 2 - 4 * a * c
    if d > 0:
        return (-b + d ** 0.5) / (2 * a), (-b - d ** 0.5) / (2 * a)
    elif d == 0:
        return -b / (2 * a)
    else:
        return None


print(quadratic_equations(2, -3, -9))
```

В Python аргументы передаются внутри функции по ссылке на объект.

### Функции с (не)изменяемыми аргументами

**Функция с неизменяемым аргументом (объектом)** меняет объект только в своей зоне видимости и возвращает новый результат:
```
>>> def no_mutable(a: int) -> int:
...     a += 4
...     return a
... 
>>> a = 0
>>> print(f'function returns {no_mutable(a)}')
function returns 4
>>> print(f'without function {a}')
without function 0
```
**Функция с изменяемым аргументом (объектом)** меняет объект не только в зоне видимости:
```
>>> def mutable(data: list[int]) -> list[int]:
...     for i, item in enumerate(data):
...         data[i] = item + 8
...     return data
... 
>>> my_list = [2, 4, 6, 8]
>>> print(mutable(my_list))
[10, 12, 14, 16]
>>> print(my_list)
[10, 12, 14, 16]
```

**Неявный return** Если в функции мы не указали слова return, значит она возвращает ничего — None

### Виды параметров (аргументов) функций

**Значения по умолчанию для параметров функции**
```
def quadratic_equations(a, b=0, c=0):
```
В качестве значения по умолчанию нельзя указывать изменяемы типы: списки, словари и т.п.

**Позиционные и ключевые параметры**
```
def func(positional_only_parameters, /, positional_or_keyword_parameters, *, keyword_only_parameters):
    pass
```
При указании параметров функции вначале идут позиционные параметры.
Косая черта не является переменной. Это символ разделитель. После неё могут идти как позиционные, так и ключевые параметры. Далее символ разделитель звёздочка указывает только на ключевые параметры.

**Только позиционная функция**
```
>>> def pos_only_arg(arg, /):
...     print(arg)
... 
>>> pos_only_arg(42)
42
>>> pos_only_arg(arg=42)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: pos_only_arg() got some positional-only arguments passed as keyword arguments: 'arg'
```

**Только ключевая функция**
```
>>> def kwd_only_arg(*, arg):
...     print(arg)
... 
>>> kwd_only_arg(42)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: kwd_only_arg() takes 0 positional arguments but 1 was given
>>> kwd_only_arg(arg=42)
42
```

**Функции со всеми вариантами параметров**
```
>>> def combined_example(pos_only, /, standard, *, kwd_only):
...     print(pos_only, standard, kwd_only)
... 
>>> combined_example(1, 2, 3) 
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: combined_example() takes 2 positional arguments but 3 were given
>>> combined_example(1, 2, kwd_only=3)
1 2 3
>>> combined_example(1, standard=2, kwd_only=3)
1 2 3
>>> combined_example(pos_only=1, standard=2, kwd_only=3)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: combined_example() got some positional-only arguments passed as keyword arguments: 'pos_only'
```

Если функция принимает несколько ключевых параметров, порядок передачи аргументов может отличаться.
```
def triangulation(*, x, y, z):
    pass

triangulation(y=5, z=2, x=11)
```

**Параметры args и kwargs**

Вместо них после звездочем могут быть любые имена, но среди разработчиков приняты имена args и kwargs

```
>>> def mean(*args):
...     return sum(args) / len(args)
... 
>>> print(mean(*[1, 2, 3]))
2.0
>>> print(mean(1, 2, 3))
2.0
```
Звёздочка при передаче в функцию упаковала все позиционные аргументы в один кортеж и наоборот при вызове функции со списком звездочка распакует его.


**kwargs принимает ключевые параметры и пакует их в словарь
```
>>> def school_print(**kwargs):
...     for key, value in kwargs.items():
...         print(f'По предмету "{key}" получена оценка {value}')
...     
... 
>>> 
>>> school_print(chimestry=5, phisics=4, math=5, fitness=5)
По предмету "chimestry" получена оценка 5
По предмету "phisics" получена оценка 4
По предмету "math" получена оценка 5
```

### Области видимости: global и nonlocal
В Python есть несколько областей видимости:
- локальная — код внутри самой функции
- глобальная — переменные заданные в файле py содержащем функцию.
- не локальная — код внешней функции, исключающий доступ к глобальным переменным.

**Локальные переменные**
```
>>> def func(y: int) -> int:
...     x = 100
...     print(f'In func {x = }') 
...     return y + 1
... 
>>>     
>>> x = 42
>>> print(f'In main {x = }')
In main x = 42
>>> z = func(x)
In func x = 100
>>> print(f'{x = }\t{z = }')
x = 42	z = 43
```

Переменная x в теле функции и переменная x в основном коде - две разные переменные

**Глобальные переменные**

```
>>> def func(y: int) -> int:
...     global x
...     x += 100
...     print(f'In func {x = }') 
...     return y + 1
... 
>>> 
>>> x = 42
>>> print(f'In main {x = }')
In main x = 42
>>> z = func(x)
In func x = 142
>>> print(f'{x = }\t{z = }')
x = 142	z = 43
```

Переменная x в теле функции объявлена как глобальная.  Изменение затронуло как внешний, так и внутренний x

**Не локальные переменные**

```
>>> def main(a):
...     x = 1
...     def func(y):
...         nonlocal x
...         x += 100
...         print(f'In func {x = }') 
...         return y + 1
...     return x + func(a)
... 
>>>     
>>> x = 42
>>> print(f'In main {x = }')
In main x = 42
>>> z = main(x)
In func x = 101
>>> print(f'{x = }\t{z = }')
x = 42	z = 44
```

**nonlocal** позволяет заглянуть на верхний уровень вложенности, но не выходить на глобальные переменные модуля.

**Доступ к константам**

```
>>> LIMIT = 1000
>>> 
>>> def func(x, y):
...     result = x ** y % LIMIT
...     return result
... 
>>> print(func(42, 73))
112
```
Константы, такие как LIMIT является глобальными

### Анонимная функция lambda
```
>>> def add_two_def(a, b):
...     return a + b
... 
>>> add_two_lambda = lambda a, b: a + b
>>> 
>>> print(add_two_def(42, 3.14))
45.14
>>> print(add_two_lambda(42, 3.14))
45.14
```

После lambda перечисляются параметры функции через запятую. Далее двоеточие и указывают значение, которое необходимо вернуть без return.

```
>>> my_dict = {'two': 2, 'one': 1, 'four': 4, 'three': 3, 'ten': 10}
>>> s_key = sorted(my_dict.items())
>>> s_value = sorted(my_dict.items(), key=lambda x: x[1])
>>> print(f'{s_key = }\n{s_value = }')
s_key = [('four', 4), ('one', 1), ('ten', 10), ('three', 3), ('two', 2)]
s_value = [('one', 1), ('two', 2), ('three', 3), ('four', 4), ('ten', 10)]
```

В первом случае словарь сортируется по ключам. Во втором благодаря лямбде указали сортировку по значению.

### Документирование кода функций
```
def max_before_hundred(*args):
    """Return the maximum number not exceeding 100."""
    m = float('-inf')
    for item in args:
        if m < item < 100:
            m = item
return m
```
где **float('-inf')** - “минус бесконечность”.

- Тройные кавычки используются, даже если строка помещается на одной
строке. Это позволяет легко расширить его позже.
- Закрывающие кавычки находятся на той же строке, что и открывающие. Это
выглядит лучше для однострочников.
- Нет пустой строки ни до, ни после строки документации.
- Строка документации — это фраза, заканчивающаяся точкой. Он описывает
действие функции или метода как команду
- Однострочная строка документации не должна повторять параметры
функции.

Если описание большое, то после первой строки идет пустая. Несколько строк описания. Закрывающие кавычки ставятся на отдельной строке.
```
def max_before_hundred(*args):
    """Return the maximum number not exceeding 100.

    :param args: tuple of int or float numbers
    :return: int or float number from the tuple args
    """
```

Такая запись автоматом помещает текст в переменную **__doc__** Описание функции можно будет получить через вызов help(max_before_hundred)

### Функции “из коробки”

abs() - возвращает абсолютное значение числа
aiter() - создает асинхронный итератор
all() - возвращает True, если все элементы истинны, иначе False
any() - возвращает True, если хотя бы один элемент истинный, иначе False
anext() - возвращает следующий элемент итератора
ascii() - возвращает строку в формате ASCII
bin() - возвращает строку с двоичным представлением числа
bool() - преобразует значение в логический тип True или False
breakpoint() - останавливает выполнение программы для отладки
bytearray() - создает массив байтов
bytes() - создает неизменяемую последовательность байтов
callable() - возвращает True, если объект может быть вызван, иначе False
chr() - возвращает символ по его коду Unicode
classmethod() - преобразует метод класса в метод, который можно вызывать без создания экземпляра класса
compile() - компилирует исходный код в объект кода или AST
complex() - создает комплексное число
delattr() - удаляет атрибут объекта
dict() - создает словарь
dir() - возвращает список имен определенных в пространстве имен
divmod() - возвращает частное и остаток от деления
enumerate() - возвращает объект, перечисляющий последовательность с индексами
eval() - выполняет строку как выражение Python
exec() - выполняет строку или блок кода
filter() - возвращает элементы последовательности, для которых функция возвращает True
float() - преобразует число или строку в число с плавающей запятой
format() - форматирует значение с использованием заданного формата
frozenset() - создает неизменяемое множество
getattr() - возвращает значение атрибута объекта по его имени
globals() - возвращает словарь глобальных символов
hasattr() - возвращает True, если объект имеет атрибут с заданным именем, иначе False
hash() - возвращает хеш-значение для объекта
help() - выводит справку по объекту
hex() - возвращает строку с шестнадцатеричным представлением числа
id() - возвращает уникальный идентификатор объекта
input() - читает строку из стандартного ввода
int() - преобразует число или строку в целое число
isinstance() - возвращает True, если объект является экземпляром заданного класса, иначе False
issubclass() - возвращает True, если класс является потомком заданного класса, иначе False
iter() - возвращает итератор для объекта
len() - возвращает длину объекта
list() - создает список
locals() - возвращает словарь локальных символов
map() - применяет функцию к каждому элементу последовательности
max() - возвращает максимальный элемент из последовательности
memoryview() - создает "память" для работы с байтовыми данными
min() - возвращает минимальный элемент из последовательности
next() - возвращает следующий элемент итератора
object() - базовый класс для всех объектов в Python
oct() - возвращает строку с восьмеричным представлением числа
open() - открывает файл или URL
ord() - возвращает код символа Unicode
pow() - возвращает результат возведения числа в степень
print() - выводит данные на стандартный вывод
property() - создает свойство для класса
range() - возвращает последовательность чисел
repr() - возвращает строковое представление объекта
reversed() - возвращает обратный итератор для последовательности
round() - округляет число до указанной точности
set() - создает множество
setattr() - устанавливает значение атрибута объекта по его имени
slice() - создает объект среза для последовательности
sorted() - возвращает отсортированную последовательность
staticmethod() - преобразует метод класса в статический метод
str() - преобразует объект в строку
sum() - возвращает сумму элементов последовательности
super() - возвращает прокси-объект для доступа к методам родительского класса
tuple() - создает кортеж
type() - возвращает тип указанного объекта
vars() - возвращает словарь атрибутов объекта
zip() - объединяет один или несколько итерируемых объектов в кортежи

### Функция map()

**map**(function, iterable) — принимает на вход функцию и последовательность.
```
>>> texts = ["Привет", "ЗДОРОВА", "привеТствую"]
>>> res = map(lambda x: x.lower(), texts)
>>> print(*res)
привет здорова приветствую
```

### Функция filter()

**filter**(function, iterable) — принимает на вход функцию и последовательность
```
>>> numbers = [42, -73, 1024]
>>> res = tuple(filter(lambda x: x > 0, numbers))
>>> print(res)
(42, 1024)
```

### Функция zip()
**zip**(*iterables, strict=False) — принимает несколько последовательностей и итерируется по ним параллельно.
Ключевой аргумент strict=True, вызовет ошибку ValueError в случае разного числа элементов
```
>>> names = ["Иван", "Николай", "Пётр"]
>>> salaries = [125_000, 96_000, 109_000]
>>> awards = [0.1, 0.25, 0.13, 0.99]
>>> for name, salary, award in zip(names, salaries, awards):
...     print(f'{name} заработал {salary:.2f} денег и премию {salary * award:.2f}')
... 
Иван заработал 125000.00 денег и премию 12500.00
Николай заработал 96000.00 денег и премию 24000.00
Пётр заработал 109000.00 денег и премию 14170.00
```

### Функция max()
**max**(iterable, *[, key, default]) или max(arg1, arg2, *args[, key])

Функция принимает на вход итерируемую последовательность или несколько
позиционных элементов и ищет максимальное из них. Ключевой параметр key
указывает на то, какие элементы необходимо сравнить, если объект является
сложной структурой. Отдельно параметр default используется для возврата
значения, если на вход передана пустой итератор.
```
>>> lst_1 = []
>>> lst_2 = [42, 256, 73]
>>> lst_3 = [("Иван", 125_000), ("Николай",
... 109_000)]
>>> print(max(lst_1, default='empty'))
empty
>>> print(max(*lst_2))
256
>>> print(max(lst_3, key=lambda x: x[1]))
('Иван', 125000)
```

### Функция min()
**min**(iterable, *[, key, default]) или min(arg1, arg2, *args[, key])
Функция работает аналогично max, но ищет минимальный элемент.
```
>>> lst_1 = []
>>> lst_2 = [42, 256, 73]
>>> lst_3 = [("Иван", 125_000), ("Николай",
... 109_000)]
>>> print(min(lst_1, default='empty'))
empty
>>> print(min(*lst_2))
42
>>> print(min(lst_3, key=lambda x: x[1]))
('Николай', 109000)
```

### Функция sum()
**sum**(iterable, /, start=0)
Функция принимает объект итератор и подсчитывает сумму всех элементов. Ключевой аргумент start задаёт начальное значение для суммирования.
```
>>> my_list = [42, 256, 73]
>>> print(sum(my_list))
371
>>> print(sum(my_list, start=1024))
1395
```

### Функция all()
**all**(iterable)
Функция возвращает истину, если все элементы последовательности являются истиной

```
>>> numbers = [42, -73, 1024]
>>> if all(map(lambda x: x > 0, numbers)):
...     print('Все элементы положительные')
... else:
...     print('В последовательности есть отрицательные и/или нулевые элементы')
... 
В последовательности есть отрицательные и/или нулевые элементы
```

### Функция any()
**any**(iterable)
Функция возвращает истину, если хотя бы один элемент последовательности являются истиной.
```
>>> numbers = [42, -73, 1024]
>>> if any(map(lambda x: x > 0, numbers)):
...     print('Хотя бы один элемент положительный')
... else:
...     print('Все элементы не больше нуля')
... 
Хотя бы один элемент положительный
```

Эти функции с линейной асимптотикой O(n), т.е. они проходят последовательно от начала до конца и возвращают результат.

### Функция chr()
**chr**(integer)
Функция возвращает строковой символ из таблицы Юникод по его номеру. Номер - целое число от 0 до 1_114_111.
```
>>> print(chr(97))
a
>>> print(chr(1105))
ё
>>> print(chr(128519))
😇
```

### Функция ord()
**ord**(char)
Функция принимает один символ и возвращает его код в таблице Юникод.
```
>>> print(ord('a'))
97
>>> print(ord('а'))
1072
>>> print(ord(' '))
32
```

### Функция locals()
Функция возвращает словарь переменных из локальной области видимости на момент вызова функции.

```
>>> def func(a, b, c):
...     x = a + b
...     print(locals())
...     z = x + c
...     return z
... 
>>> func(1, 2, 3)
{'a': 1, 'b': 2, 'c': 3, 'x': 3}
6
```

### Функция globals()

Функция возвращает словарь переменных из глобальной области видимости, т.е. из пространства модуля.

```
print(globals())
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)> }
...
>>> print(func(1, 2, 3))
{'__name__': '__main__', '__doc__': None, '__package__': None, '__loader__': <class '_frozen_importlib.BuiltinImporter'>, '__spec__': None, '__annotations__': {}, '__builtins__': <module 'builtins' (built-in)>, 'new_var': <built-in function id>, 'no_mutable': <function no_mutable at 0x7f579f08b7e0>, 'a': 0 }
...
6
```

Если вызвать функцию locals() из основного кода модуля, а не из функции, результат будет аналогичен работе функции globals().
В отличии от locals словарь globals позволяет изменить значение переменной!

### Функция vars()
Функция без аргументов работает аналогично функции locals(). Если передать в vars объект, функция возвращает его атрибут __dict__. А если такого атрибута нет у объекта, вызывает ошибку TypeError.
```
>>> print(vars(int))
{'__new__': <built-in method __new__ of type object at 0x956cc0>, '__repr__': <slot wrapper '__repr__' of 'int' objects>, '__hash__': <slot wrapper '__hash__' of 'int' objects>, '__getattribute__': <slot wrapper '__getattribute__' of 'int' objects>, '__lt__': <slot wrapper '__lt__' of 'int' objects>, '__le__': <slot wrapper '__le__' of 'int' objects>, '__eq__': <slot wrapper '__eq__' of 'int' objects>, '__ne__': <slot wrapper '__ne__' of 'int' objects>, '__gt__': <slot wrapper '__gt__' of 'int' objects> }
...
```